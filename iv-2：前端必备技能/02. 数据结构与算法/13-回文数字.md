# 1-10000 之间的对称数（回文）

## 题目

打印 1-10000 之间的对称数

## 方式1：使用数组反转

- 数字转换为字符串
- 字符串转换为数组 reverse ，再 join 生成字符串
- 比较前后的字符串

## 方式2：使用字符串头尾比较

- 数字转换为字符串
- 字符串头尾比较

还可以使用**栈**（但栈会用到数组，性能不如直接操作字符串）（像括号匹配，但要注意奇偶数）
- 数字转换为字符串，求长度
- 如果长度是偶数，则用栈比较
- 如果长度是奇数，则忽略中间的数字，其他的用栈比较

## 方式3：生成反转数

- 通过 `%` 和 `Math.floor` 将数字生成一个反转数
- 比较前后的数字
- 全称操作数字，没有字符串类型

## 性能分析

时间复杂度看似相当，都是 `O(n)`

- 但 方案1 涉及到了数组的转换和操作，就需要耗费大量的时间
    - 数组 reverse 需要时间
    - 数组和字符串的转换需要时间
- 方案 2 3 比较，数字操作最快。电脑的原型就是计算器，所以处理数字是最快的。
- 思路2要用栈，不合适。因为栈也一般用数组实现，会慢

## 答案

第三种方案，参考 palindrome-number.ts

## 划重点

- 尽量不要转换数据格式，尤其注意数组（有序结构，不能乱来～）
- 尽量不要使用内置 API ，如 reverse，不好判断时间复杂度
- 数字操作最快，其次是字符串
