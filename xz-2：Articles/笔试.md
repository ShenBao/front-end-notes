# 笔试

使用 js (es5&es6+ 均可) 实现以下效果： 

```js
var priorityQueue = new PriorityQueue();
priorityQueue.enqueue('优先级1-1', 1);
priorityQueue.enqueue('优先级3-1', 3);
priorityQueue.enqueue('优先级1-2', 1);
priorityQueue.enqueue('优先级2-1', 2);
priorityQueue.print();
// 优先级1-1 优先级1-2 优先级2-1 优先级3-1 priorityQueue.dequeue();
```

```js
function PriorityQueue() {
            this.item = [];
            // 添加
            PriorityQueue.prototype.enqueue = function (valstr, index) {
                this.item.push({ name: valstr, index });
            };
            //删除
            PriorityQueue.prototype.dequeue = function (valstr, index) {
                this.item.shift();
            };
            // print 
            PriorityQueue.prototype.print = function () {
                // 不修改原来的队列
                let arr = JSON.parse(JSON.stringify(this.item));
                arr.sort((a, b) => {
                    return a.index - b.index
                });
                // 排序之后  添加到数组中  
                let srr = [];
                arr.forEach(element => {
                    srr.push(element.name)
                });
                // 最终输出 
                console.log(srr);
            }
        }

        let priorityQueue = new PriorityQueue();
        priorityQueue.enqueue('优先级1-1', 1)
        priorityQueue.enqueue('优先级3-1', 3)
        priorityQueue.enqueue('优先级1-2', 1)
        priorityQueue.enqueue('优先级2-1', 2);
        priorityQueue.print();
        priorityQueue.dequeue()
```

基于React实现一个可复用的展示鼠标位置的高阶组件（HOC），要求接收一个组件，返回一个新的组件。

```js
// 书写你的代码
// const ComponentWithMouse = withMouse(Component)
// ReactDOM.render(<ComponentWithMouse />, document.getElementById('root'))
import React from 'react'
export default (Component) => {
 return class WrappedComponent extends React.Component {
    constructor(props){
      super(props)
      this.state = {
        positionX: 0,
        positionY: 0
      }
    }
    componentDidMount() {
      document.addEventListener('mousemove', (e) => {
        this.setState({
          positionX: e.clientX,
          positionY: e.clientY
        })
      }) 
    }
    render(){
      return(
        <Component {...this.props} {...this.state}/>
      )
    }
    
  }
}
```

将类似以下JSON表示的树状结构（可以无限层级）通过parseDOM函数（使用document.createElement，document.createTextNode，appendChild等方法）生成一颗DOM树（返回一个element元素）

```js
const JsonTree = {
  "tagName": "ul",
  "props": {
    "className": "list",
    "data-name": "jsontree"
  },
  "childern": [{
      "tagName": "li",
      "childern": [{
        "tagName": "img",
        "props": {
          "src": "//img.alicdn.com/tps/TB1HwXxLpXXXXchapXXXXXXXXXX-32-32.ico",
          "width": "16px"
        }
      }]
    },
    {
      "tagName": "li",
      "childern": [{
        "tagName": "a",
        "props": {
          "href": "https://www.aliyun.com",
          "target": "_blank"
        },
        "children": "阿里云"
      }]
    }
  ]
};

function parseDOM(jsontree){
  const {tagName,props,childern} = jsontree;
  const element = document.createElement(tagName);
  //请实现过程
  //....
  for(let key in props){
  	element[key]=props[key]
  }
  if(childern && typeof(childern)==="object"){
     for(let i=0;i<childern.length;i++){
       element.appendChild(parseDOM(childern[i]))
     }
  }else{
  	if(childern){
       element.appendChild(document.createTextNode(childern))
       }
  }
  return element;
}
```

请用您除「冒泡排序」外最熟悉的一种排序算法，将 [3, 5, 7, 2, 1, 8, 9, 0, 6, 23, 54, 75, 1, 5, 8] 这样的一个数组进行由小到大或由大到小的排序，并用注释说明您所用算法的优缺点

```js
//1. 请在这里编写一个排序函数
function sort（arr）{
	if(arr.length<=1){
  	return arr
  }
  let left=[]
  let right=[]
  let mid =arr[0]
  for(let i=1;i<arr.length;i++){
  	if(arr[i]<mid){
    	left.push(arr[i])
    }else{
      right.push(arr[i])
    }
  }
  return ([...sort(left),mid,...sort(right)])
}

//2. 请在这里说明所选算法的优缺点
// 优点：效率高 
// 缺点：不稳定，不适合对象排序
```
